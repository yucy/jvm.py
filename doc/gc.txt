==========================================================
gc模块的自动垃圾回收机制
必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。这个机制的主要作用就是发现并处理不可达的垃圾对象。

垃圾回收=【垃圾检查】+【垃圾回收】

在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。
==========================================================
# 打印阀值
print(gc.get_threshold())
默认输出 (700, 10, 10)

# 设置自动执行垃圾回收的频率
gc.set_threshold(600,10,5)

# 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表
gc.get_count()
输出格式：(481, 8, 0)
==========================================================
(700, 10, 10) 表示：后面的两个10。每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收
而700表示距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目。【注意是内存分配，而不是引用计数的增加】

每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器
例如，假设阀值是(700,10,10)：

    当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)
    当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)
    当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)

==========================================================
有三种情况会触发垃圾回收：
1.调用gc.collect(),
2.当gc模块的计数器达到阀值的时候。
3.程序退出的时候
==========================================================