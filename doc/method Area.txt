方法区 Method Area 

运行时常量池
常量池存放的是该类型所用到的常量的有序集合

类型信息
1 ．类型的完全限定名
2 ．类型直接超类的完全限定名 
3 ．直接超接口的全限定名列表 
4 ．该类型是类类型还是接口类型 
5 ．类型的访问修饰符（如 public,abstract,final 等，对应 access_flags. )

字段信息,包括类级变量和实例变量，不包括局部变量
1 ．字段名 
2 ．字段的类型（可能是基本类型或引用类型）
3 ．字段的修饰符（ pUblic 、 Static 、transient等）
注意的是，字段的顺序也要保留

方法信息
1 ．方法名
2 ．方法返回类型 
3 ．方法参数的个数、类型和顺序等 
4 ．方法的修饰符 
5 ．方法的字节码（ bytecodes 非本地方法具有） 
6 ．操作数栈和该方法在栈帧中局部变量的大小等 
7 ．异常表。

类变量分为两种变量： 
1 ．运行时变量，在准备阶段就赋予默认值.
2 ．编译时变量，static+属性表中存在ContentValue属性，直接赋予ContentValue的值。（如果其他类引用了此变量，直接把变量的值写进其class文件流中，这在编译时处理）

类加载器的引用
一个类可以被启动类加载器或者自定义的类加载器加载，如果一个类被某个自定义类加载器的对象（实例）加载，则方法区中必须保存对该对象的引用。注意：如果是被JVM内部加载器加载，则此项为None

指向 Class 实例的引用
在加载过程中，虚拟机会创建一个代表该类型的 Class 对象，方法区中必须保存对该对象的引用

方发表
为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，JVM 的实现者还可以添加一些其他的数据结构，如方法表。 jvm 对每个加载的非虚拟类的类型信息中都添加了一个方法表，方法表是一组对类实例方法的直接引用（包括从父类继承的方法）。 jvm 可以通过方法表快速激活实例方法．